---
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { init as initLexer, parse } from 'es-module-lexer';
import MarkdownIt from 'markdown-it';
import { markdownItShikiTwoslashSetup } from 'markdown-it-shiki-twoslash';
import { Node, Project } from 'ts-morph';

import { ExerciseBox } from './ExerciseBox';

const markdownParser = new MarkdownIt();

const shiki = await markdownItShikiTwoslashSetup({
  theme: 'nord', // for some reason when providing multiple themes it throws error
});

markdownParser.use(shiki);

const modules = import.meta.glob('../exercise/**/*.js', {
  as: 'raw',
}) as Record<string, () => Promise<string>>;

interface Props {
  moduleName: string;
  group: string;
}

const { moduleName, group } = Astro.props;

const applicableModules = new Map<string, () => Promise<string>>();
for (const [modulePath, getModuleContent] of Object.entries(modules)) {
  const relativePath = path.relative(path.resolve('../exercise', moduleName, group), modulePath);
  if (!relativePath.startsWith('..')) {
    applicableModules.set(relativePath, getModuleContent);
  }
}

async function groupModules(modules: Map<string, () => Promise<string>>) {
  const questionModule = new Map<string, [() => Promise<string>, string]>();
  const solutionModule = new Map<string, () => Promise<string>>();
  const testModule = new Map<string, () => Promise<string>>();

  modules.forEach((getModule, key) => {
    const solutionMatch = key.match(/(.+)\.solution\.([j|t]sx?)$/);

    if (solutionMatch) {
      solutionModule.set(`${solutionMatch[1]}.${solutionMatch[2]}`, getModule);
      return;
    }
    const testMatch = key.match(/(.+)\.(?:spec|test)\.([j|t]sx?)$/);

    if (testMatch) {
      testModule.set(`${testMatch[1]}.${testMatch[2]}`, getModule);
      return;
    }

    const questionMatch = key.match(/(.+)\.([j|t]sx?)$/);

    if (questionMatch) {
      questionModule.set(`${questionMatch[1]}.${questionMatch[2]}`, [getModule, questionMatch[2]]);
    }
  });

  const result = new Map<
    string,
    {
      question: string;
      test: string;
      solution: string;
      extension: string;
      docs: string;
    }
  >();

  await initLexer;

  for (const [key, [getQuestion, extension]] of questionModule) {
    const getTest = testModule.get(key);
    const getSolution = solutionModule.get(key);

    if (getSolution && getTest) {
      let [question, test, solution] = await Promise.all([getQuestion(), getTest(), getSolution()]);

      const [imports] = parse(test);

      imports.forEach((importSpecifier) => {
        if (importSpecifier.n && importSpecifier.n.includes('.solution')) {
          test = `${test.slice(0, importSpecifier.s)}${'./index'}${test.slice(importSpecifier.e)}`;
        }
      });

      const project = new Project({
        compilerOptions: {
          allowJs: true,
        },
      });

      const source = project.createSourceFile(
        path.resolve(fileURLToPath(import.meta.url), '..', `problem.${extension}`),
        question
      );

      const defaultExportedSymbol = source.getDefaultExportSymbol();

      let docs = '';

      if (defaultExportedSymbol) {
        const declarations = defaultExportedSymbol.getDeclarations();

        declarations.forEach((declaration) => {
          if (Node.isFunctionDeclaration(declaration)) {
            const jsDocs = declaration.getJsDocs();

            jsDocs.forEach((doc) => {
              const commentText = doc.getCommentText();

              if (commentText) {
                docs += `${commentText}\r\n`;
                question = question.substring(0, doc.getPos()) + question.substring(doc.getEnd());
              }
            });
          }
        });
      }

      result.set(key, {
        question: question.trim(),
        test,
        solution,
        extension,
        docs: docs && markdownParser.render(docs),
      });
    }
  }

  return result;
}

const questionGroup = await groupModules(applicableModules);

const [firstExercise, ...exercises] = [...questionGroup];
---

<section>
  <div class="flex flex-col gap-10">
    {firstExercise && <ExerciseBox exercise={firstExercise[1]} heading="Exercise 1" client:load />}
    {
      exercises.map(([, exercise], index) => (
        <ExerciseBox exercise={exercise} heading={`Exercise ${index + 2}`} client:visible />
      ))
    }
  </div>
</section>
