---
import { formatDate, isFuture } from '~/lib/date';
import type { MarkdownHeading } from 'astro';
import './shiki.css';
import { clsx } from 'clsx';

export interface Props {
  title: string;
  headings?: Array<MarkdownHeading>;
  publishDate?: Date;
}

const { title, publishDate, headings } = Astro.props;

const isFutureContent = publishDate && isFuture(publishDate);

const levelTwoHeadings =
  headings && headings.filter((h) => h.depth === 2 && h.slug !== 'footnote-label');

const hasHeadings = levelTwoHeadings && levelTwoHeadings.length > 0;
---

<style>
  @screen xl {
    .toc {
      width: calc(1072px - 768px - 16px);
    }
  }

  .toc-item,
  .content-title {
    text-wrap: balance;
  }
</style>

<div class="mb-12">
  <article>
    <header class="flex flex-col mb-8 sm:pb-8 sm:border-b sm:border-gray-100">
      <div class={clsx('relative max-w-3xl w-full', hasHeadings ? 'mx-auto xl:ml-0' : 'mx-auto')}>
        {
          publishDate && (
            <p class="my-3 text-zinc-400 pl-4 border-l-4 border-l-zinc-100">
              {isFutureContent ? `To be published on ` : null}
              {formatDate(publishDate)}
            </p>
          )
        }
        <h1 class="content-title text-3xl sm:text-4xl font-bold w-full">
          {title}
        </h1>
      </div>
    </header>
    {
      hasHeadings && (
        <nav
          aria-labelledby="toc-label"
          class="mb-8 max-w-3xl mx-auto xl:float-right xl:sticky xl:top-14 xl:flex xl:justify-end xl:-mr-12"
        >
          <div class="sr-only" id="toc-label">
            Table of content
          </div>
          <ol class="toc flex flex-col gap-2 xl:gap-4">
            {levelTwoHeadings!.map((h) => (
              <li class="toc-item">
                <a
                  href={`#${h.slug}`}
                  class="text-zinc-500 underline xl:text-sm xl:no-underline transition hover:text-primary-600"
                  data-target={h.slug}
                >
                  {h.text}
                </a>
              </li>
            ))}
          </ol>
        </nav>
      )
    }
    <div
      class={clsx('max-w-3xl prose', hasHeadings ? 'mx-auto xl:ml-0' : 'mx-auto')}
      data-md-content
    >
      <slot />
    </div>
  </article>
</div>

<script>
  import { listen } from '~/lib/event-helper';

  document.querySelectorAll('[aria-labelledby="toc-label"]').forEach((toc) => {
    const links = toc.querySelectorAll<HTMLElement>('.toc-item > a');

    const headings: Array<{
      element: HTMLElement;
      top: number;
    }> = [];

    links.forEach((element) => {
      const target = element.dataset.target;

      const targetElement = target && document.getElementById(target);

      if (targetElement) {
        const scrollMt = parseFloat(window.getComputedStyle(targetElement).scrollMarginTop);

        const top =
          window.scrollY +
          targetElement.getBoundingClientRect().top -
          scrollMt -
          window.innerHeight / 2;

        headings.push({
          top,
          element,
        });
      }
    });

    if (headings.length === 0) {
      return;
    }

    const mediaQuery = window.matchMedia('(min-width: 1280px)');

    let cleanup: () => void | undefined;

    function syncLinks() {
      let top = window.scrollY;
      let current = headings[0];
      for (let heading of headings) {
        if (top >= heading.top) {
          current = heading;
        } else {
          break;
        }
      }
      if (current) {
        links.forEach((link) => {
          if (link === current.element) {
            link.classList.add('text-primary-500');
            link.classList.remove('text-zinc-500');
          } else {
            link.classList.add('text-zinc-500');
            link.classList.remove('text-primary-500');
          }
        });
      }
    }

    function setupScrollListener() {
      if (mediaQuery.matches) {
        if (cleanup) cleanup();

        syncLinks();
        cleanup = listen(window, 'scroll', syncLinks, { passive: true });
      } else {
        if (cleanup) cleanup();
        links.forEach((link) => {
          link.classList.add('text-zinc-500');
          link.classList.remove('text-primary-500');
        });
      }
    }

    setupScrollListener();

    listen(mediaQuery, 'change', setupScrollListener);
  });
</script>

<script>
  import { createTooltip } from '~/lib/create-tooltip';

  const mdContents = document.querySelectorAll('[data-md-content]');

  mdContents.forEach((mdContent) => {
    const footNoteRef = mdContent.querySelectorAll('a[data-footnote-ref]');

    footNoteRef.forEach((el) => {
      const parentSupEl = el.closest('sup');

      if (!parentSupEl) {
        return;
      }

      const href = el.getAttribute('href');
      if (href) {
        const target = document.querySelector(href);
        if (target && target instanceof HTMLElement) {
          const childs: Array<Node> = [];
          target.childNodes.forEach((childNode) => {
            if (childNode instanceof HTMLElement) {
              const cloned = document.createElement('div');
              cloned.innerHTML = childNode.innerHTML;
              cloned.childNodes.forEach((grandChild) => {
                if (
                  grandChild instanceof HTMLElement &&
                  grandChild.hasAttribute('data-footnote-backref')
                ) {
                  grandChild.remove();
                }
              });
              childs.push(cloned);
            }
          });
          if (childs.length > 0) {
            const tooltipEl = document.createElement('div');
            tooltipEl.role = 'tooltip';
            childs.forEach((child) => tooltipEl.appendChild(child));
            const arrowEl = document.createElement('div');
            tooltipEl.appendChild(arrowEl);
            parentSupEl.insertAdjacentElement('afterend', tooltipEl);

            createTooltip({
              anchor: el,
              tooltip: tooltipEl,
              arrow: arrowEl,
            });
          }
        }
      }
    });
  });
</script>
