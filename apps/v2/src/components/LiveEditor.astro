---
import { CodeIcon, PlayIcon } from './icons';
import { LiveEditor } from './LiveEditor';

interface Props {
  previewMinHeight?: string;
  codeMaxHeight?: string;
  autoPlay?: boolean;
  readOnly?: boolean;
}

const { previewMinHeight = 'auto', codeMaxHeight = 'auto', autoPlay, readOnly } = Astro.props;
---

<style define:vars={{ previewMinHeight, codeMaxHeight }}>
  [data-live-editor] {
    --preview-min-height: var(--previewMinHeight);
    --code-max-height: var(--codeMaxHeight);
  }
</style>
<div
  class="bg-gray-100 text-zinc-900 dark:bg-zinc-600 dark:text-zinc-200 rounded-xl"
  data-live-editor
  data-autoplay={autoPlay && 'true'}
  data-readonly={readOnly && 'true'}
>
  <div class="flex justify-between items-center px-2 py-1 offline:hidden">
    <span class="font-techie text-sm uppercase font-medium tracking-widest" data-editor-mode></span>
    <div class="inline-flex gap-2">
      <button
        type="button"
        class="p-1 bg-white dark:bg-zinc-400 rounded-full"
        data-edit-button
        aria-label="Edit"
      >
        <PlayIcon aria-hidden className="w-6 h-6 text-gray-500 dark:text-zinc-700" />
      </button>
      <button
        type="button"
        data-cancel-button
        aria-label="Cancel"
        class="p-1 bg-white dark:bg-zinc-400 rounded-full hidden"
      >
        <CodeIcon aria-hidden className="w-6 h-6 text-gray-500 dark:text-zinc-700" />
      </button>
    </div>
  </div>
  <div data-editor-code>
    <slot />
  </div>
  <div class="hidden border border-gray-100 dark:border-zinc-600" data-editor>
    <LiveEditor readOnly={readOnly} client:load>
      <slot />
    </LiveEditor>
  </div>
</div>

<script>
  import scrollIntoView from 'scroll-into-view-if-needed';
  import { editorLoadedEvent } from '~/components/editor-event';
  import { isVisible } from '~/lib/dom-helpers';

  const languagePriority: Record<string, number> = {
    tsx: 4,
    ts: 4,
    js: 3,
    jsx: 3,
    html: 2,
    css: 1,
  };

  const liveEditors: NodeListOf<HTMLDivElement> = document.querySelectorAll('[data-live-editor]');

  liveEditors.forEach((editorSectionElement) => {
    const editButtonElement = editorSectionElement.querySelector('[data-edit-button]');
    const cancelButtonElement = editorSectionElement.querySelector('[data-cancel-button]');
    const codeElement = editorSectionElement.querySelector('[data-editor-code]');
    const editorElement = editorSectionElement.querySelector('[data-editor]');
    const modeElement = editorSectionElement.querySelector('[data-editor-mode]');
    const allCodeSnippetElements = Array.from(editorSectionElement.querySelectorAll('pre'));

    const langBySnippet = new WeakMap<HTMLPreElement, string>();

    allCodeSnippetElements.forEach((codeSnippetElement) => {
      const languageIdElement = codeSnippetElement.querySelector('.language-id');
      const language = languageIdElement && languageIdElement.textContent;
      if (language) {
        langBySnippet.set(codeSnippetElement, language);
      }
    });

    const getElementToTransition = () => {
      const visibleCodeSnippets = Array.from(allCodeSnippetElements)
        .filter(isVisible)
        .sort((a, b) => {
          const aLanguage = langBySnippet.get(a);
          const bLanguage = langBySnippet.get(b);

          const aPriority = (aLanguage && languagePriority[aLanguage]) || 0;
          const bPriority = (bLanguage && languagePriority[bLanguage]) || 0;

          return bPriority - aPriority;
        });

      return visibleCodeSnippets[0];
    };

    const getEditorActiveLanguageSnippet = (): HTMLElement | undefined => {
      const activeFileTab =
        editorElement && editorElement.querySelector('.sp-tab-button[data-active="true"]');

      const activeFileLanguage = activeFileTab?.textContent?.split('.').pop();

      if (activeFileLanguage) {
        return allCodeSnippetElements.find(
          (snippet) => langBySnippet.get(snippet) === activeFileLanguage && isVisible(snippet)
        );
      }
    };

    if (codeElement && editButtonElement && cancelButtonElement && editorElement && modeElement) {
      const currentEditorElement = editorElement as HTMLElement;

      const showLiveEditor = () => {
        editButtonElement.classList.add('hidden');
        cancelButtonElement.classList.remove('hidden');
        modeElement.textContent = editorSectionElement.dataset.readonly ? 'Running' : 'Editing';
        const codeStyle = window.getComputedStyle(codeElement);
        const codeHeight = codeStyle.getPropertyValue('height');
        codeElement.classList.add('hidden');
        currentEditorElement.classList.remove('hidden');
        currentEditorElement.style.setProperty('--editor-height', codeHeight);
      };

      const hideLiveEditor = () => {
        cancelButtonElement.classList.add('hidden');
        editButtonElement.classList.remove('hidden');
        modeElement.textContent = null;

        currentEditorElement.classList.add('hidden');
        codeElement.classList.remove('hidden');
      };

      let prevElement: HTMLElement | null = null;

      const animationSettings = {
        easing: 'cubic-bezier(0, 0, 0.2, 1)',
        duration: 250,
      };

      const showLiveEditorWithTransition = (fallbackElementToTransition: HTMLElement) => {
        const elementToTransition = getEditorActiveLanguageSnippet() || fallbackElementToTransition;

        const before = elementToTransition.getBoundingClientRect();

        showLiveEditor();

        if ('animate' in elementToTransition) {
          prevElement = elementToTransition;
          requestAnimationFrame(() => {
            const target = currentEditorElement.querySelector(
              '.sp-code-editor, .editor-scrollable'
            );
            if (target && target instanceof HTMLElement) {
              const after = target.getBoundingClientRect();

              const invertDiff = {
                x: before.left - after.left,
                y: before.top - after.top,
              };

              target.animate(
                [
                  { transform: `translate(${invertDiff.x}px, ${invertDiff.y}px)` },
                  { transform: `translate(0px, 0px)` },
                ],
                animationSettings
              );
            }
          });
        }
      };

      const edit = () => {
        const elementToTransition = getElementToTransition();

        if (elementToTransition) {
          const lazyEditor = currentEditorElement.querySelector('[data-editorloaded]');

          if (
            lazyEditor &&
            lazyEditor instanceof HTMLElement &&
            lazyEditor.dataset.editorloaded === 'false'
          ) {
            // the editor is initialized lazily, so we force it to initialize by
            // showing it then hide again, and to reduce UI jank we set it a low
            // opacity during this process
            currentEditorElement.style.setProperty('opacity', '0.01');
            showLiveEditor();

            function onEditorLoaded() {
              currentEditorElement.style.removeProperty('opacity');
              hideLiveEditor();
              lazyEditor && lazyEditor.removeEventListener(editorLoadedEvent, onEditorLoaded);
              requestAnimationFrame(() => {
                showLiveEditorWithTransition(elementToTransition);
              });
            }
            lazyEditor.addEventListener(editorLoadedEvent, onEditorLoaded);
          } else {
            showLiveEditorWithTransition(elementToTransition);
          }
        } else {
          prevElement = null;
          showLiveEditor();
        }
      };

      const cancelEdit = () => {
        const currentElement = currentEditorElement.querySelector(
          '.sp-code-editor, .editor-scrollable'
        );

        if (prevElement && currentElement && currentElement instanceof HTMLElement) {
          const elementToTransition = getEditorActiveLanguageSnippet() || prevElement;

          const before = currentElement.getBoundingClientRect();

          hideLiveEditor();

          requestAnimationFrame(() => {
            const after = elementToTransition.getBoundingClientRect();

            const invertDiff = {
              x: before.left - after.left,
              y: before.top - after.top,
            };

            // increase z index to avoid getting blocked
            elementToTransition.style.setProperty('z-index', '9999');
            const animation = elementToTransition.animate(
              [
                { transform: `translate(${invertDiff.x}px, ${invertDiff.y}px)` },
                { transform: `translate(0px, 0px)` },
              ],
              animationSettings
            );

            animation.finished.then(() => {
              elementToTransition.style.removeProperty('z-index');
            });
          });
        } else {
          hideLiveEditor();
        }
      };

      editButtonElement.addEventListener('click', edit);
      cancelButtonElement.addEventListener('click', cancelEdit);
    }
  });

  liveEditors.forEach((editorSection) => {
    editorSection.querySelectorAll('.code-container').forEach((codeContainer) => {
      if (isVisible(codeContainer as HTMLElement)) {
        const highlightedLine = codeContainer.querySelector('.line.highlight');

        if (highlightedLine) {
          scrollIntoView(highlightedLine, {
            scrollMode: 'if-needed',
            boundary: codeContainer,
          });
        }
      }
    });
  });

  const autoPlayEditors: Array<HTMLDivElement> = [];

  liveEditors.forEach((editorSectionElement) => {
    if (editorSectionElement.dataset.autoplay) {
      autoPlayEditors.push(editorSectionElement);
    }
  });

  if (autoPlayEditors.length) {
    import('~/lib/intersection-observer').then(({ onIntersectOnce }) => {
      onIntersectOnce({
        elements: autoPlayEditors,
        callback: (editorSectionElement) => {
          if (editorSectionElement instanceof HTMLElement) {
            const editBtn = editorSectionElement.querySelector('[data-edit-button]');
            if (
              editBtn &&
              isVisible(editBtn as HTMLElement) &&
              'click' in editBtn &&
              typeof editBtn.click === 'function'
            ) {
              editBtn.click();
              // hack to simulate showEditor
            }
          }
        },
        observeOptions: {
          rootMargin: '0px',
          threshold: 0.5,
        },
      });
    });
  }
</script>
