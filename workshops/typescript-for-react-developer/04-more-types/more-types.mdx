---
title: More Types in TypeScript
description: 'Learn type alias, interface, and index signature.'
date: '2019-10-17'
updated_at: '2019-11-25'
---

## Type Alias

Type alias is the naming of type, so you can reuse it.

```ts live
// instead of
const sanitize = (data: string | number) => {};
const clean = (data: string | number) => {};

// create a type alias to reuse
type StringOrNumber = string | number;
const sanit = (data: StringOrNumber) => {};
const clea = (data: StringOrNumber) => {};
```

Type alias is not limited to primitive, you can use it to name object type or function signature as well.

```ts live
type Job = {
  name: string;
  salary: number;
};

const a: Job = {
  name: 'programmer',
  salary: 0,
};

type Callback = () => void;

const hello: Callback = () => {
  console.log('Hello!');
};

type NumberOrStringArray = Array<number | string>;

const items: NumberOrStringArray = [3, 'three', 4, 5];
```

## Interface

Interface can be used to describe object and function. Interface cannot be used to describe primitive, such as `string` or `boolean`.

```ts live
interface Job {
  name: string;
  salary: number;
}

interface SuckyJob extends Job {
  boring: true;
}
```

Most of the thing that you can do using `interface` can be done using `type`, so I usually just use `type` whenever possible.

<aside>

What are the things that `interface` can do but `type` can't?

1. declaration merging (extending an existing interface). This is usually only concerned by library developer, in which their interface can be extended.
1. self-reference. Because `type` is eagerly evaluated, therefore you can't use declare a `type` that refers itself. Meanwhile, `interface` is lazily evaluated, therefore it can refer itself. Nonetheless, this limitation of `type` will be removed in TypeScript 3.7, which is in beta when I am writing this.

</aside>

## Index signature

One of the common usage of JavaScript is to use object as a simple key-value map object that you can use to lookup value.

Consider the example below:

```js
const pokemonCache = {};

const getPokemon = id => 
  {
    if (pokemonCache[id]) {
      // if pokemon is already available, return it.
      return Promise.resolve(pokemonCache[id])
    }

    // else fetch the pokemon data from api, cache it and return it
    return fetch(`https://pokemon-json.herokuapp.com/api/pokemons/${id}`)
      .then(res => res.json())
      .then(pokemon => {
        pokemonCache[id] = pokemon;
        return pokemon;
      });
  };
```

How can we declare typing of `pokemonCache`?

Index signature.

```ts live
type Pokemon = {
  id: number;
  name: string;
  sprite: string;
  thumbnail: string;
}

const pokemonCache: {[id: number]: Pokemon} = {};

const getPokemon = id => 
  {
    if (pokemonCache[id]) {
      return Promise.resolve(pokemonCache[id])
    }

    return fetch(`https://pokemon-json.herokuapp.com/api/pokemons/${id}`)
      .then(res => res.json())
      .then((pokemon: Pokemon) => {
        pokemonCache[id] = pokemon;
        return pokemon;
      });
  };
```

## Declaration Space

One of the implicit understanding of TypeScript is that there are two types of declaration: type declaration and variable declaration. 

Following are a few type declarations:

```ts noWrapper
interface Animal {
  name: string;
  greet: () => void;
}

type Person = {
  firstName: string;
  talk: () => void;
}
```

Which means you can use them as type annotation:

```ts noWrapper
const animal: Animal = {
  name: 'dog',
  greet: () => {
    console.log(`Woff! Woff!`)
  }
}

const me: Person = {
  firstName: 'Malcolm',
  talk: () => {
    console.log(`Hello!`);
  }
}
```

But you can't use them as variable:

```ts noWrapper
const person = Person; // Error
```

Similarly, when you declare a variable, you can't use it as type annotation:

```ts live
const person = {
  name: '',
  talk: () => {
    console.log(`Sawatika`);
  }
}

const me: person = {
  name: '',
  talk: () => {
    console.log(`Sawatika`);
  }
}
```

If what you want is to get the type of a variable and apply it to another variable, you can use the `typeof` keyword:

```ts live
const person = {
  name: '',
  talk: () => {
    console.log(`Sawatika`);
  }
}

const me: typeof person = {
  name: '',
  talk: () => {
    console.log(`Sawatika`);
  }
}
```