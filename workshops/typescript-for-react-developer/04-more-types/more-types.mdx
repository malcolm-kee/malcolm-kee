---
title: More Types in TypeScript
description: 'Learn type alias, interface, and index signature.'
date: '2019-10-17'
updated_at: '2019-12-02'
---

## Type Alias

Type alias is the naming of type, so you can reuse it.

```ts live
// instead of
const sanitize = (data: string | number) => {};
const clean = (data: string | number) => {};

// create a type alias to reuse
type StringOrNumber = string | number;
const sanit = (data: StringOrNumber) => {};
const clea = (data: StringOrNumber) => {};
```

Type alias is not limited to primitive, you can use it to name object type or function signature as well.

```ts live
type Job = {
  name: string;
  salary: number;
};

const a: Job = {
  name: 'programmer',
  salary: 0,
};

type Callback = () => void;

const hello: Callback = () => {
  console.log('Hello!');
};

type NumberOrStringArray = Array<number | string>;

const items: NumberOrStringArray = [3, 'three', 4, 5];
```

## Interface

Interface can be used to describe object and function. Interface cannot be used to describe primitive, such as `string` or `boolean`.

```ts live
interface Job {
  name: string;
  salary: number;
}

interface SuckyJob extends Job {
  boring: true;
}
```

Most of the thing that you can do using `interface` can be done using `type`, so I usually just use `type` whenever possible.

<aside>

What are the things that `interface` can do but `type` can't?

1. declaration merging (extending an existing interface). This is usually only concerned by library developer, in which their interface can be extended. (We will discuss how to extend third-party library type definition in the [Using Third Party Types](/typescript-for-react-developer/using-third-party-types))
1. self-reference. Because `type` is eagerly evaluated, therefore you can't use declare a `type` that refers itself. Meanwhile, `interface` is lazily evaluated, therefore it can refer itself. Nonetheless, this limitation of `type` is removed in TypeScript 3.7, which is just released few weeks ago before this workshop.

</aside>

## Accessing Type of an Object Type Property

Sometimes you want to extract out the type of an Object Type and use it somewhere. Consider the example below:

```ts
type PersonDetails = {
  name: string;
  address: {
    unit: string;
    streetOrBuilding: string;
    street: string;
  }
}

export const updateAddress = (
  currentDetails: PersonDetails, 
  address: {
    unit: string;
    streetOrBuilding: string;
    street: string;
  }
): PersonDetails => ({
  ...currentDetails,
  address
})
```

`updateAddress` is a function that accept two parameters: `currentDetails` which is the current value, and `address` which is the new address details, and merge them together and returns a new object.

Note that we have duplicated the address type in two places. We can remove that duplication by creating a type for the address:

```ts
// highlight-start
type Address = {
  unit: string;
  streetOrBuilding: string;
  street: string;
}
// highlight-end

type PersonDetails = {
  name: string;
  address: Address; // highlight-line
}

export const updateAddress = (
  currentDetails: PersonDetails, 
  address: Address // highlight-line
): PersonDetails => ({
  ...currentDetails,
  address
})
```

However, sometimes this is not possible because you don't have control over type definition (e.g. type from library) so you can't just refactor the type definition.

The solution is to extract the type of the property like this:

```ts
type PersonDetails = {
  name: string;
  address: {
    unit: string;
    streetOrBuilding: string;
    street: string;
  }
}

export const updateAddress = (
  currentDetails: PersonDetails, 
  address: PersonDetails['address'] // highlight-line
): PersonDetails => ({
  ...currentDetails,
  address
})
```

## Index signature

One of the common usage of JavaScript is to use object as a simple key-value map object that you can use to lookup value.

Consider the example below:

```js
const pokemonCache = {};

const getPokemon = id => 
  {
    if (pokemonCache[id]) {
      // if pokemon is already available, return it.
      return Promise.resolve(pokemonCache[id])
    }

    // else fetch the pokemon data from api, cache it and return it
    return fetch(`https://pokemon-json.herokuapp.com/api/pokemons/${id}`)
      .then(res => res.json())
      .then(pokemon => {
        pokemonCache[id] = pokemon;
        return pokemon;
      });
  };
```

How can we declare typing of `pokemonCache`?

Index signature.

```ts live
type Pokemon = {
  id: number;
  name: string;
  sprite: string;
  thumbnail: string;
}

const pokemonCache: {[id: number]: Pokemon} = {};

const getPokemon = id => 
  {
    if (pokemonCache[id]) {
      return Promise.resolve(pokemonCache[id])
    }

    return fetch(`https://pokemon-json.herokuapp.com/api/pokemons/${id}`)
      .then(res => res.json())
      .then((pokemon: Pokemon) => {
        pokemonCache[id] = pokemon;
        return pokemon;
      });
  };
```

## Declaration Space

One of the implicit understanding of TypeScript is that there are two types of declaration: type declaration and variable declaration. 

Following are a few type declarations:

```ts noWrapper
interface Animal {
  name: string;
  greet: () => void;
}

type Person = {
  firstName: string;
  talk: () => void;
}
```

Which means you can use them as type annotation:

```ts noWrapper
const animal: Animal = {
  name: 'dog',
  greet: () => {
    console.log(`Woff! Woff!`)
  }
}

const me: Person = {
  firstName: 'Malcolm',
  talk: () => {
    console.log(`Hello!`);
  }
}
```

But you can't use them as variable:

```ts noWrapper
const person = Person; // Error
```

Similarly, when you declare a variable, you can't use it as type annotation:

```ts live
const person = {
  name: '',
  talk: () => {
    console.log(`Sawatika`);
  }
}

const me: person = {
  name: '',
  talk: () => {
    console.log(`Sawatika`);
  }
}
```

If what you want is to get the type of a variable and apply it to another variable, you can use the `typeof` keyword:

```ts live
const person = {
  name: '',
  talk: () => {
    console.log(`Sawatika`);
  }
}

const me: typeof person = {
  name: '',
  talk: () => {
    console.log(`Sawatika`);
  }
}
```

## Type Assertion

Sometimes, some values are really dynamic that there are no ways for TypeScript to do type-checking for you. 

Consider the following example:

```ts live
const profileImage = document.querySelector('#profile');

console.log(profileImage.src) // Error because `src` property may not be there
```

If we really sure that the `document.querySelector` call returns an image, we can make a type assertion to tell TypeScript:

```ts noWrapper
const profileImage = document.querySelector('#profile');

console.log((profileImage as HTMLImageElement).src); // highlight-line
```

Note that type assertion does nothing in runtime; if the `document.querySelector` calls above returns a `div` instead of a `img`, the call could cause error.
